caste LoadManager() { 
  
observe ServiceRequestor, Worker; 
  
var nWorkers: int; 
  
var nMachines: int; 
  
var index: int; 
  
var jobQueueLength: int; 
  
var listOfWorkers : ListOfWorkers; 
  
var listOfMachines: ListOfMachineIPs; 
  
var worker: Worker;  
  
action AllocateJob(i: int, j: Job){ 
  
 
index:= index+1;  
  
 
if (index>=nWorkers){index:=0;} 
  
} 
  
action stopWorker(i: int){ } 
  
action AddWorker(){ 
  
  var machineIP: string; 
  
  machineIP:=listOfMachines[nWorkers%nMachines]; 
  
  create worker of Worker(nWorkers) @ machineIP;  
  
  till worker: iAmReady();  
  
  listOfWorkers[nWorkers] := worker;  
  
  nWorkers:=nWorkers+1; 
  
} 
  
action ReduceWorker(){ 
  
 
nWorkers:=nWorkers-1; 
  
 
stopWorker(nWorkers); 
  
} 
  
init { 
  
 
listOfMachines := … /* initialise the var */ 
  
 
nMachines :=listOfMachines.length; 
  
 
nWorkers:=0; 
  
 
for (var j:=0 to 4) { AddWorker(); }; 
  
 
index:=0; 
  
 
jobQueueLength:=0;  
  
} 
  
body{ 
  
 
var job: Job;  
  
 
when exist R in ServiceRequestor:  
  
 
 
RequestService(rcv job) { 
  
 
 
AllocateJob(index, job); 
  
 
 
jobQueueLength := jobQueueLength+1; 
  
 
 
if (jobQueueLength / (nWorkers+1) >=10){ 
  
 
 
 
AddWorker(); 
  
 
 
}; 
  
 
}; 
  
 
when exist W in Worker: JobDone() { 
  
 
 
jobQueueLength := jobQueueLength-1; 
  
 
 
if ((jobQueueLength < nWorkers )  
  
 
 
 
&& (nWorkers >1 ))  { 
  
 
 
 
ReduceWorker(); 
  
 
 
}; 
  
 
}; 
  
} 
} 
The above load balancer is elastic. The number of unfinished 
jobs per worker on average is calculated as a measure of the 
load. When it is greater than a threshold (10), the load 
balancer will create a new worker to deal with the demand. 
When it drops to below 1, at least one worker must be idle so 
it is removed. The actions that implement addition and 
removal of a worker are AddWorker and ReduceWorker. 
The caste Worker below implements the service providers. 
It defines two actions: JobDone for announcing that a job has 
been finished by the service provider and iAmReady for 
announcing that the service has finished initialisation and is   
ready to take on jobs.  
uses LoadManager; 
caste Worker(id : int) { 
  
observe LoadManager; 
  
var myId: int; 
  
var workerId: int; 
  
var job: Job; 
  
action JobDone(wID: int) { } 
  
action iAmReady() { } 
  
init { 
  
 
myId:= id;  
  
 
iAmReady(); 
  
} 
  
body{ 
  
 
var hasNoWorkToDo: Bool;  
  
 
hasNoWorkToDo := true; 
  
 
when exist B in LoadManager:  
  
 
 
AllocateJob(rcv workerId, rcv job){ 
  
 
 
if (workerId == myId) { 
  
 
 
 
hasNoWorkToDo:= false; 
  
 
 
 
wait 100;  /* Do job */  
  
 
 
 
JobDone(myId);  
  
 
 
} 
  
 
}; 
  
 
if (hasNoWorkToDo) { 
  
 
 
when exist B in LoadManager: 
  
 
 
 
stopWorker(myId){ 
  
 
 
 
destroy;  
  
 
 
} 
  
 
} 
  
} 
} 
Note that when a worker receives the instruction to stop, 
it will complete the queue of jobs already allocated to it.  
B. The Integrated DevOps Environment CIDE 
CIDE is an integrated DevOps Environment for the 
CAOPLE language. Figure 6 is the user interface for editing 
and compiling CAOPLE programs; there are also tools for 
deploying and executing code.  
 
Figure 6. CIDE’s Graphical User Interface for Editing Code 
Caste is the unit both of compilation and of deployment. 
There are no build or link operations. Each machine in a 
cluster can run either a Communication Engine (CE) or a 
Logic Execution Engine (LEE) or both, where CE and LEE 
are two parts of the CAVM-2 virtual machine. The object 
codes of the castes are deployed to the CEs and the agents 
(i.e. the instances of the castes) run on the LEEs. Any LEE 
can be chosen no matter where the object code is deployed. 
The CE manages communication between agents. Each 
cluster can have multiple CEs and LEEs.  
The user can view the set of nodes in the network and 
select a subset of them as his/her working cluster as shown in 
Error! Reference source not found.. Each virtual machine 
on the nodes can be, with a click, switched on (green) or off