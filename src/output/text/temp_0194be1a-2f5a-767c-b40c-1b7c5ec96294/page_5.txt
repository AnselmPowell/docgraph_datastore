back to a paper from 1973 [32], proposes actors as universal 
primitives of concurrent computation. Each actor is an entity 
that can do the following:   
a) Send messages to other actors; 
b) Perform computation in response to messages it 
receives;  
c) Create new actors either locally or remotely.  
An actor A may modify its own private state but it cannot 
directly change that of another actor B, though B may choose 
to change its state in response to a message from A.  
Messages sent between actors must be:  
• 
Sent directly to the receiver using a unique reference to 
the receiver known to the sender; 
• 
Location transparent, meaning that the sender only 
needs the receiver’s reference but not its location; 
• 
Asynchronous, meaning that the sender is not blocked 
waiting for delivery of the message.  
A sender A can obtain the unique reference to a receiver 
B in one of the following ways: 
• 
Initial condition: B is one of a number of fixed actors in 
the system environment known to all actors in the 
system.  
• 
Parenthood: When A creates B, A obtains the unique 
reference to B.  
• 
Endowment: When A is created, its parent passes it the 
reference to B.  
• 
Introduction: Another actor C has sent A the reference 
to B.  
The above so-called reference capability model is 
identical to that of object-orientation and is too restrictive for 
service-oriented systems. For this reason, Akka adds to these 
four the ability for A to search for the reference to B. Akka is 
based on the so-called supervision hierarchy structure of 
actor systems. If an actor A creates actor B, then A is the 
parent of B in the hierarchy and B is one of its children. As 
shown in Figure 5, the hierarchy has three guardian nodes as 
follows. 
• User Guardian, representing the user, and which can 
create multiple actor systems.  
• System Guardian, which creates all the System’s internal 
actors.  
• Root Guardian, which creates them both.  
 
 
Figure 5. Akka’s Supervision Hierarchy of Actors [33] 
An actor can then be searched for from some point in the 
hierarchy, using an Akka method like actorSelection(…), 
and often using a wildcard.  
The supervision hierarchy also enforces the management 
responsibility of actors in that a parent is responsible for 
terminating its children and dealing with their failures. An 
actor has four lifecycle methods, each of which can be 
overridden. 
• 
preStart(): invoked after the actor has been created and 
just before the actor is started; 
• 
postStop(): invoked just after the actor is stopped; 
• 
preRestart(): invoked just before a failed child actor is 
restarted, as might be done as part of the actor’s failure 
management strategy; 
• 
postRestart(): invoked just after the restart, enabling re-
initialization of the actor.  
It is possible to conceive of a pure actor system in which 
everything is an actor, including even primitive data types 
such as integers, real numbers and strings, but no practical 
programming language exists for this as far as we know. 
More usually, an actor is a kind of system component, such 
as a web service, obtained by adding an Akka library to an 
existing programming language such as Scala or Java [33]. 
More than 50 other such libraries are listed in the Wikipedia 
page for Actor model [34].  
An alternative is to extend an existing programming 
language with language facilities for supporting actors, as 
seen with ActorScript [Error! Bookmark not defined.]. 
More than 20 programming languages claim to support the 
actor model [34], but Akka is   perhaps the most mature 
implementation of the actor model.  
B. Reactive Model 
The reactive model is event-driven whereas the actor model 
is message-driven; both are asynchronous. The distinction 
between the two is that messages are directed to a clear 
single destination, whereas events are not: they are “facts for 
others to observe” [35].  
A consequence of this is that in the reactive 
programming style, control flow is driven not by the thread 
of execution but by the availability of new information. 
Reactive programming languages therefore make it possible 
to specify what actions must be taken in response to state 
changes. These state changes are thereby automatically and 
efficiently propagated across the network of dependent 
computations by the underlying execution model. For this 
reason, the reactive model has become popular for 
concurrent programming, although its origins are in the 
dataflow declarative programming languages of the 1980s 
[36]. 
Like actor-based programming, reactive programming 
can be enabled with either a language extension or a new 
library. Of the dozen such approaches recorded in a survey 
published in 2013 [36], the ReactiveX library for cloud 
computing has received particular attention from industry.  
ReactiveX 
provides 
operators 
for 
declaratively 
composing sequences of data and events while abstracting 
away 
from 
concerns 
such 
as 
low-level 
threading, 
synchronization, thread-safety, concurrent data structures,