and non-blocking I/O. Such operators include those to filter, 
select, transform, combine or compose sequences and 
resemble those of functional programming languages.  
ReactiveX is polyglot in the sense that it has been 
extended to many (18 so far) languages, giving for example 
RxJava as used by Netflix to make their entire service layer 
asynchronous, RxPython and RxJS (for JavaScript); it has 
also been extended to three platforms. 
ReactiveX provides a framework based on the Observer 
design pattern. An abstract class Observable (the Subject 
class in the Observer pattern) may emit any number of items 
(including zero) and then terminate either successfully or 
with an error. Another abstract class Subscriber (the 
Observer class in Observer pattern) reacts to this sequence in 
a manner specified in a concrete subclass by overriding three 
abstract methods: 
• 
onNext(), invoked when it receives an item;  
• 
onComplete(), invoked when it terminates successfully;  
• 
onError(), invoked when it fails with an error.  
A subscriber links to an Observable object by invoking 
the latter’s method subscribe(Subscriber: sub), obtaining a 
Subscription object that can then later be cancelled. The 
Observable then invokes onNext(), onComplete() and 
onError() when appropriate.  
In the Android platform version of ReactiveX, the 
Observables and Subscribers may be placed on different 
threads, by using different arguments in two method calls 
observerOn(scheduler) and subscriberOn(scheduler). 
C.  
Service Agent Model 
As a part of software engineering methodology for internet-
based applications, in 2000 we proposed an agent-oriented 
parallel computing model [37, 38], which turns out to be a 
good fit for cloud applications in the microservices 
architecture. Here, agent means service provider, as in estate 
agent and travel agent. Although our notion of agent was 
inspired by the notion of agent in distributed artificial 
intelligence, it is different from that in the agent models 
proposed and advanced in the AI community. Each agent is a 
computational entity that is:  
• 
Active, running on its own process, and distributed to a 
network of computers, and  
• 
Autonomous, in that only the agent itself can change its 
own state and it decides which actions to perform and 
when.  
An agent encapsulates the following elements: 
• 
A set of state variables, each of which can either be 
visible to other agents outside or invisible to them and 
known only by the agent itself.  
• 
A set of actions the agent can perform, each of which on 
termination generates an event that will be seen by other 
agents if the action is visible to them 
• 
A description of the environment, which lists which 
other agents are being observed for their visible actions 
and states.  
• 
A set of behavior rules, defining how the agents change 
their state and take action in response to external events 
and changes in internal conditions.  
Another crucial concept of our model is caste, which acts 
as the classifier for agents in much the same way as class is 
the classifier for objects. Each caste can therefore be thought 
of as a template from which agents are instantiated and 
created. Similarly, a caste can inherit from another caste. 
However, whereas an object’s membership of a class is fixed 
at compile time, an agent can join, quit, suspend and resume 
its 
membership 
to 
a 
caste 
dynamically, 
thereby 
demonstrating adaptive behavior.  
Here is an example of caste in the CAOPLE 
programming language, which is based on the service agent 
model. Please see Section V for more information about 
CAOPLE.  
CASTE Chatter(givenName: STRING){ 
 
OBSERVE Chatter;  
 
VAR name: STRING;  
 
ACTION Say(word: STRING) { } 
 
INIT{  
 
 
 
name:=givenName; 
 
 
 
Say("Hello, World!") ;  
 
} 
 
BODY{  
 
 
WHEN EXIST x in Chatter:Say("Hello, World!"){ 
 
 
 
Say("Hello, ” + x.name);  
 
 
} 
 
} 
} 
 
The OBSERVE clause indicates that each agent of caste 
Chatter observes all other agents of the caste. The INIT 
clause is the list of statements executed when the agent is 
created; these save parameter givenName into visible state 
variable name and perform the action Say(“Hello, World!”). 
The BODY clause, which is repeatedly executed until the 
agent terminates, responds to any such action from another 
agent x with the action Say(“Hello, ” + x.name), where 
x.name is the name of x.  
The communication mechanism here, in which one agent 
takes 
visible 
actions 
while 
another 
observes, 
is 
fundamentally 
different 
from 
the 
subscribe-publish 
mechanism because agents can be created, deployed over a 
network, and destroyed dynamically. This is a close match 
with the needs of microservices architecture, where a service 
must communicate with multiple copies of other services 
that are dynamically created and deployed to multiple 
machines in a cluster. In spite of this flexibility, strong type 
checking can be performed statically. 
A further virtue of this mechanism, in addition to its 
simplicity, is that communication is location transparent and 
at a high level of abstraction; the programmer does not need 
to know which agents are in the system, nor where they are 
in the network, nor any details about communication ports or 
low-level synchronization primitives. Furthermore, when an 
agent’s action is observed, its identity can be obtained if 
needed, as is done with agent x above. This breaks the 
reference capability limitation.  
There is strong support in the service agent model for 
code deployment to a remote machine. For example, the 
following statements deploy two agents of caste Chatter to 
two different machines.  
 
CREATE Chatter(“John”) @ "192.168.1.65";