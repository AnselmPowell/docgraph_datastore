TABLE I
SUMMARY OF ATTRIBUTES ON 2,923 GITHUB PROJECTS.
Attribute
Min
Median
Max
Mean
St. Dev.
Age (years)
5.0
6.8
8.9
6.9
0.7
Commits
100
422
25, 052
918.3
1, 483.2
Total PRs
1
32
4, 418
91.1
192.5
Total issues
1
47
3, 465
142.4
284.5
Size (MB)
0.1
2.0
928.4
12.4
42.9
Developers
3
15
690
29.8
45.2
least ﬁve years (last update timestamp minus project creation
timestamp) by January of 2016. This condition ensures that the
projects are long-lived. With this criterion, we were left with
431,879 projects. Among those projects, we only consider non-
forked projects (i.e., projects that are not cloned from other
projects), as forked projects may bring bias to our conclusions
with their duplicate code and documents. With this condition,
only 304,694 projects were left.
We also ﬁlter out projects with fewer than 100 commits
to avoid small scale and toy projects. If a project involves
fewer than 3 contributors, we also remove it from our data set.
Additionally, since RQ3 studies the role of branches on coping
with contributions (PRs in GitHub) by others, each selected
project should have at least one closed PR (contributors can
submit a PR to any branch as they wish). Considering the
number of commits, contributors and closed PRs have been
listed in each project’s website in GitHub, we wrote a web
crawler to retrieve these numbers and directly compared them
with our threshold values. After ﬁltering, only 2,938 projects
met all the above criteria.
When we analyzed the remaining projects, we found that
there were 15 projects that do not speciﬁcally target developing
software but instead focus on documenting tasks. For example,
the project msgpack/msgpack6, mainly focuses on manag-
ing the speciﬁcation of MessagePack format. These projects
were also eliminated from the 2,938 projects. Ultimately, 2,923
GitHub projects were selected as our experimental subjects.
Table I shows more details on our collected project data.
In our experiment, we downloaded each project using git
clone. Then, for each project we retrieved all branches used
(using git branch -r). In total, we retrieved 19,389 branches
created for the 2,923 projects. We used these collected data to
conduct our experiments and answer the ﬁve RQs.
B. Design of RQs
We attempt to gain insight into the branch usage in OSS
projects via ﬁve RQs. In RQ1, we provide an overall view of
branches used in 2,923 projects. We further investigate some
characteristics of projects that use relatively more branches
during development. In RQ2, we investigate branching purpose
in GitHub. In RQ3, we study the branches that are requested
for merging PRs. We further study whether all commits of
other branches make it into master branches in RQ4. Finally
in RQ5, we examine the impact of branches usage on projects’
productivity. We combine bar plots, non-parametric statistical
hypothesis tests, and regression models to answer our RQs.
6https://github.com/msgpack/msgpack
In RQ1, we use bar plot and Wilcoxon Rank Sum test [34]
to observe the overall usage of branches across the 2,923
projects. In RQ2, we manually check each branch’s content
and then provide some descriptive statistics on the purpose
of branch use. In RQ3, we calculate the number of pushed
pull requests (PRs) in each branch, and investigate the role
of branches in coping with PRs in GitHub. In RQ4, we count
the number of commits that are unique to non-master branches
and perform statistics to understand the ﬂowing of commits
from non-master branches to master branches. In RQ5, we use
a multiple linear regression model [25] to measure the impact
of branch usage on the overall productivity of projects. In
particular, we adopt Cohen’s f 2 to capture the effect size of
branching on project’s productivity. The detailed description
about the regression model and Choen’s f 2 will be presented
in Section III-C. During our model building for RQ5, we
also use eight confounding factors that may affect project’s
productivity. These confounding factors are listed as follows:
Forks: The number of forks of a project. Outsiders (developers
who cannot directly commit to a project) must fork a project
if they want to contribute to it. More forks may indicate that
more developers are involved in a project’s development. This
may affect a project’s ﬁnal productivity.
Watchers: The number of watchers of a project. In general,
the more watchers a project has, the more popular it is
among developers; a project’s popularity may affect its overall
productivity.
Project age: Project’s age since its creation. A project’s age
is calculated as the last update timestamp minus the creation
timestamp. A longer-lived project may have more commits
than a relatively short-lived project.
Project size: Project’s size measured as total physical space
a project needs to store its data (MB). Generally speaking,
different projects with different sizes may behavior differently,
thus leading to different project productivity.
Number of PRs: The number of PRs requested to merge into
the project. PR is a form of contributions. More PRs indicate
that more contributions are requested to merge into the project.
This may result in an increase of project productivity.
Number of PR comments: The number of comments made
on PRs. More comments on PRs may indicate an active
response to contributions by developers. This may result in a
quicker resolution to PRs, which may further affect a project’s
productivity.
Number of issue comments: The number of comments
made on issues. More comments on issues may indicate
active interactions among developers to ﬁx bugs. This may
facilitate a project’s development and ﬁnally affect a project’s
productivity [7].
Number of developers: The number of developers contribut-
ing to a project. More developers contributing to a project may
indicate a higher project’s productivity.
The details about above eight confounding factors can be
found in Table II.
308
Authorized licensed use limited to: Nanjing University. Downloaded on May 20,2020 at 13:25:16 UTC from IEEE Xplore.  Restrictions apply.